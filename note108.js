const css = ``;if (!document.getElementById("modal-dark-css")) { const s = document.createElement("style"); s.id = "modal-dark-css"; s.textContent = css; document.head.appendChild(s); } function renderDropdownMenuPortal(trigger, options, callback) { document .querySelectorAll(".custom-dropdown-portal-menu") .forEach((e) => e.remove()); const menu = document.createElement("div"); menu.className = "custom-dropdown-portal-menu active"; menu.setAttribute("role", "listbox"); options.forEach((o) => { const opt = document.createElement("div"); opt.className = "custom-dropdown-option"; opt.tabIndex = 0; opt.dataset.value = typeof o === "object" ? o.value : o; opt.textContent = typeof o === "object" ? o.label : o; opt.setAttribute("role", "option"); opt.addEventListener("click", () => { callback(o); menu.remove(); }); opt.addEventListener("keydown", (ev) => { if (ev.key === "Enter") { ev.preventDefault(); opt.click(); } }); menu.appendChild(opt); }); document.body.appendChild(menu); const rect = trigger.getBoundingClientRect(); menu.style.width = rect.width + "px"; let left = rect.left + window.scrollX; const rightEdge = left + rect.width; const viewportWidth = window.innerWidth; if (rightEdge > viewportWidth) { left -= rightEdge - viewportWidth; } if (left < 0) left = 0; menu.style.left = left + "px"; menu.style.top = rect.bottom + window.scrollY + "px"; function closeOnOutside(ev) { if (!menu.contains(ev.target) && ev.target !== trigger) { menu.remove(); document.removeEventListener("mousedown", closeOnOutside); } } document.addEventListener("mousedown", closeOnOutside); window.addEventListener( "scroll", () => { if (document.body.contains(menu)) { const rect = trigger.getBoundingClientRect(); let leftNew = rect.left + window.scrollX; const rightNewEdge = leftNew + rect.width; if (rightNewEdge > window.innerWidth) { leftNew -= rightNewEdge - window.innerWidth; } if (leftNew < 0) leftNew = 0; menu.style.left = leftNew + "px"; menu.style.top = rect.bottom + window.scrollY + "px"; menu.style.width = rect.width + "px"; } }, { passive: true } ); return menu; } let modalBackdrop = null; let modalResolver = null; let modalScope = {}; function ensureModal() { if (modalBackdrop) return; modalBackdrop = document.createElement("div"); modalBackdrop.className = "modal-backdrop"; modalBackdrop.setAttribute("aria-hidden", "true"); document.body.appendChild(modalBackdrop); modalBackdrop.addEventListener("click", (e) => { if (e.target === modalBackdrop) closeModal(); }); document.addEventListener("keydown", (e) => { if (e.key === "Escape" && modalBackdrop.classList.contains("active")) { closeModal(); } }); }; function closeModal(result = null) { if (modalBackdrop) { modalBackdrop.classList.remove("active"); document.documentElement.style.overflow = ""; } modalScope = {}; if (modalResolver) { modalResolver(result); modalResolver = null; } setTimeout(() => { if (modalBackdrop) { modalBackdrop.innerHTML = ""; } }, 300); } function applyModalStyles(element) { if (element.tagName === "INPUT") { element.classList.add("modal-input"); } else if (element.tagName === "TEXTAREA") { element.classList.add("modal-textarea"); } else if (element.tagName === "SELECT") { element.classList.add("modal-select"); } else if (element.tagName === "BUTTON") { element.classList.add("modal-btn"); } element .querySelectorAll("input, textarea, select, button") .forEach((child) => { applyModalStyles(child); }); } function createModalScope(container) { const scope = {}; container.querySelectorAll("[id]").forEach((element) => { if (element.id) { scope[element.id] = element; } }); return scope; } function validateModalFields(container) { let isValid = true; const fields = container.querySelectorAll( "input, textarea, .custom-dropdown-trigger" ); fields.forEach((field) => { field.style.borderColor = ""; if (field.hasAttribute("data-skip-validation")) { return; } let isEmpty = false; if ( field.tagName === "INPUT" && (field.type === "text" || field.type === "email" || field.type === "url") ) { isEmpty = field.value.trim() === ""; } else if (field.classList.contains("custom-dropdown-trigger")) { isEmpty = (field.dataset.value || "").trim() === ""; } else if (field.tagName === "TEXTAREA") { isEmpty = field.value.trim() === ""; } if (isEmpty) { field.style.borderColor = "var(--danger)"; isValid = false; const clearValidation = () => { field.style.borderColor = ""; field.removeEventListener("input", clearValidation); field.removeEventListener("change", clearValidation); }; field.addEventListener("input", clearValidation); field.addEventListener("change", clearValidation); } }); return isValid; } function collectFormValues(container) { const values = {}; container.querySelectorAll("[id]").forEach((element) => { if (element.id) { if (element.tagName === "INPUT") { if (element.type === "checkbox" || element.type === "radio") { values[element.id] = element.checked; } else { values[element.id] = element.value; } } else if ( element.tagName === "TEXTAREA" || element.tagName === "SELECT" ) { values[element.id] = element.value; } else if (element.classList.contains("custom-dropdown-trigger")) { values[element.id] = element.dataset.value || element.textContent; } } }); return values; } window.showModal = function (options = {}) { ensureModal(); return new Promise((resolve) => { modalResolver = resolve; modalScope = {}; modalBackdrop.innerHTML = ""; const modalWindow = document.createElement("div"); modalWindow.className = "modal-window"; modalWindow.setAttribute("role", "dialog"); modalWindow.setAttribute("aria-modal", "true"); const headerDiv = document.createElement("div"); headerDiv.className = "modal-header"; if (options.header) { if (typeof options.header === "string") { headerDiv.innerHTML = options.header; } else if (options.header instanceof HTMLElement) { headerDiv.appendChild(options.header); } } else { const titleEl = document.createElement("h3"); titleEl.className = "modal-title"; titleEl.textContent = options.title || ""; titleEl.id = "modal-title-" + Math.random().toString(36).slice(2); const closeBtn = document.createElement("button"); closeBtn.className = "modal-close"; closeBtn.setAttribute("aria-label", "Close dialog"); closeBtn.innerHTML = "&#x2715;"; closeBtn.addEventListener("click", closeModal); headerDiv.appendChild(titleEl); headerDiv.appendChild(closeBtn); modalWindow.setAttribute("aria-labelledby", titleEl.id); } const bodyDiv = document.createElement("div"); bodyDiv.className = "modal-body"; if (options.body) { if (typeof options.body === "string") { bodyDiv.innerHTML = options.body; } else if (options.body instanceof HTMLElement) { bodyDiv.appendChild(options.body); } else if (Array.isArray(options.body)) { bodyDiv.innerHTML = options.body.join(""); } } const footerDiv = document.createElement("div"); footerDiv.className = "modal-footer"; if (options.footer) { if (typeof options.footer === "string") { footerDiv.innerHTML = options.footer; } else if (options.footer instanceof HTMLElement) { footerDiv.appendChild(options.footer); } else if (Array.isArray(options.footer)) { footerDiv.innerHTML = options.footer.join(""); } } else { footerDiv.innerHTML = '<button class="modal-btn">OK</button>'; } applyModalStyles(headerDiv); applyModalStyles(bodyDiv); applyModalStyles(footerDiv); modalScope = createModalScope(bodyDiv); footerDiv.querySelectorAll("button").forEach((button) => { const onclickAttr = button.getAttribute("onclick"); if (onclickAttr) { button.removeAttribute("onclick"); button.addEventListener("click", () => { if (onclickAttr !== "closeModal()") { if (!validateModalFields(bodyDiv)) { showNotification("Please fill in all required fields."); return; } } try { with (modalScope) { eval(`(function() { ${onclickAttr} })()`); } } catch (error) { console.error("Error executing button action:", error); } }); } else { button.addEventListener("click", () => { if (validateModalFields(bodyDiv)) { const values = collectFormValues(bodyDiv); closeModal({ action: button.textContent || button.id || "unknown", values }); } else { showNotification("Please fill in all required fields."); } }); } }); bodyDiv.querySelectorAll("[onclick]").forEach((element) => { const onclickAttr = element.getAttribute("onclick"); if (onclickAttr) { element.addEventListener("click", () => { try { with (modalScope) { eval(`(function() { ${onclickAttr} })()`); } } catch (error) { console.error("Error executing element action:", error); } }); element.removeAttribute("onclick"); } }); bodyDiv .querySelectorAll(".custom-dropdown-trigger") .forEach((trigger) => { const options = JSON.parse(trigger.dataset.options || "[]"); trigger.addEventListener("click", () => { renderDropdownMenuPortal(trigger, options, (selected) => { trigger.textContent = selected.label; trigger.dataset.value = selected.value; trigger.dispatchEvent(new Event("change", { bubbles: true })); }); }); }); modalWindow.appendChild(headerDiv); modalWindow.appendChild(bodyDiv); modalWindow.appendChild(footerDiv); modalBackdrop.appendChild(modalWindow); document.documentElement.style.overflow = "hidden"; modalBackdrop.classList.add("active"); setTimeout(() => { const firstInput = bodyDiv.querySelector( "input, textarea, select, button" ); if (firstInput) firstInput.focus(); }, 100); }); }; window.modalSubmit = function () { const bodyEl = modalBackdrop.querySelector(".modal-body"); if (validateModalFields(bodyEl)) { const values = collectFormValues(bodyEl); closeModal({ action: "submit", values }); } else { showNotification("Please fill in all required fields."); } }; window.closeModal = closeModal; window.createModalElement = function (type, opts = {}) { const out = { el: null, input: null }; type = type.toLowerCase(); const wrapper = document.createElement("div"); wrapper.className = "modal-element"; if (opts.label) { const lbl = document.createElement("label"); lbl.className = "modal-label"; lbl.textContent = opts.label; wrapper.appendChild(lbl); } if (type === "message") { const p = document.createElement("div"); p.className = "modal-message"; p.textContent = opts.text || ""; out.el = wrapper; wrapper.appendChild(p); return out; } if (type === "input") { const input = document.createElement("input"); input.className = "modal-input"; input.type = opts.inputType || "text"; if (opts.placeholder) input.placeholder = opts.placeholder; if (opts.value) input.value = opts.value; if (opts.key) input.dataset.modalKey = opts.key; if (opts.visibleIf) wrapper.dataset.visibleIf = opts.visibleIf; wrapper.appendChild(input); out.el = wrapper; out.input = input; return out; } if (type === "textarea") { const ta = document.createElement("textarea"); ta.className = "modal-textarea"; ta.rows = opts.rows || 3; if (opts.placeholder) ta.placeholder = opts.placeholder; if (opts.key) ta.dataset.modalKey = opts.key; if (opts.visibleIf) wrapper.dataset.visibleIf = opts.visibleIf; wrapper.appendChild(ta); out.el = wrapper; out.input = ta; return out; } if (type === "checkbox" || type === "radio") { const input = document.createElement("input"); input.className = "modal-input"; input.type = type; if (opts.key) input.dataset.modalKey = opts.key; if (opts.visibleIf) wrapper.dataset.visibleIf = opts.visibleIf; wrapper.appendChild(input); out.el = wrapper; out.input = input; return out; } if (type === "select") { const wrapper2 = document.createElement("div"); wrapper2.className = "custom-dropdown"; const trigger = document.createElement("div"); trigger.className = "custom-dropdown-trigger modal-input"; trigger.tabIndex = 0; const options = opts.options || [{ label: "Select option", value: "" }]; trigger.textContent = options[0].label; trigger.dataset.value = options[0].value; trigger.dataset.options = JSON.stringify(options); trigger.addEventListener("click", () => { renderDropdownMenuPortal(trigger, options, (selected) => { trigger.textContent = selected.label; trigger.dataset.value = selected.value; trigger.dispatchEvent(new Event("change")); }); }); if (opts.key) trigger.dataset.modalKey = opts.key; wrapper2.appendChild(trigger); if (opts.visibleIf) wrapper2.dataset.visibleIf = opts.visibleIf; wrapper.appendChild(wrapper2); out.el = wrapper; out.input = trigger; return out; } if (type === "button") { const btn = document.createElement("button"); btn.type = "button"; btn.className = "modal-inline-button modal-btn"; btn.textContent = opts.value || opts.label || "Button"; if (opts.ariaLabel) btn.setAttribute("aria-label", opts.ariaLabel); const lowerLabel = (opts.value || opts.label || "").toLowerCase(); if (lowerLabel.includes("cancel") || lowerLabel.includes("close")) { btn.style.background = "#373737"; btn.style.color = "#eeeeee"; } else { btn.style.background = "var(--accent2)"; btn.style.color = "#052027"; } if (typeof opts.onClick === "function") { btn.addEventListener("click", opts.onClick); } if (opts.visibleIf) wrapper.dataset.visibleIf = opts.visibleIf; wrapper.appendChild(btn); out.el = wrapper; out.input = btn; return out; } if (type === "row") { const container = document.createElement("div"); container.className = "modal-row"; if (opts.position) { container.setAttribute("data-position", opts.position); } (opts.children || []).forEach((child) => { if (child instanceof Node) { container.appendChild(child); } else if (child.el) { container.appendChild(child.el); } }); out.el = container; return out; } out.el = wrapper; return out; }; ensureModal();    
window.handleRename=function(){const e=preserveSelection(async function(){if(!currentNote)return void showNotification("No note selected");const t=currentNote.title||"",n=currentNote.extension||"",o=await showModal({header:'<div class="modal-title">Rename Note</div>',body:`<div style="display:flex;gap:10px;align-items:center;"><div style="flex:1;"><label class="modal-label">Name</label><input type="text" id="newTitle" placeholder="Enter Name" value="${t.replace(/"/g,"&quot;")}"></div></div><div style="display:flex;gap:10px;align-items:center;"><div style="flex:1;"><label class="modal-label">Extension</label><input type="text" id="newExtension" placeholder="Enter Extension" value="${n.replace(/"/g,"&quot;")}"></div></div>`,footer:'<button onclick="closeModal()">Cancel</button><button onclick="handleRenameSubmit()" class="modal-btn">OK</button>'});if(!o||"OK"!==o.action)return;let a=String(o.newTitle||"").trim(),i=String(o.newExtension||"").trim();if(!a&&!i)return;a=a||t,i=i||n,currentNote.title=a,currentNote.extension=i.replace(/^\./,"").toLowerCase(),currentNote.lastEdited=new Date().toISOString();const l=notes.findIndex(e=>e.id===currentNote.id);-1!==l&&(notes[l].title=a,notes[l].extension=currentNote.extension,notes[l].lastEdited=currentNote.lastEdited),updateNoteMetadata(),populateNoteList(),updateDocumentInfo(),showNotification("Note updated!"),currentHighlightLanguage="none",immediatePlainRender(),noteBackdrop.style.color="var(--color)",noteBackdrop.offsetHeight,scheduleUpdate(!0)});return"function"==typeof e?e():e};window.handleRenameSubmit=function(){closeModal({action:"OK",newTitle:modalScope.newTitle?modalScope.newTitle.value:"",newExtension:modalScope.newExtension?modalScope.newExtension.value:""}),setTimeout(()=>{currentHighlightLanguage="none",immediatePlainRender(),scheduleUpdate(!0)},50)};
window.handleFormat = function (t) { return preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; if (s === e) { showNotification(`Please select text to ${t}!`); return; } const formatOptions = t === "italic" ? "MarkDown (*text*),MarkUp (<i>text</i>)" : t === "underline" ? "MarkDown (__text__),MarkUp (<u>text</u>)" : t === "bold" ? "MarkDown (**text**),MarkUp (<b>text</b>)" : "MarkDown (```),MarkUp (<code>)"; const optionsArray = [ { label: "Select option", value: "" }, { label: formatOptions.split(",")[0], value: "1" }, { label: formatOptions.split(",")[1], value: "2" } ]; const result = await showModal({ header: `<div class="modal-title">${ t[0].toUpperCase() + t.slice(1) } Text</div>`, body: ` <label class="modal-label">Choose Format</label> <div class="custom-dropdown"> <div id="formatType" class="custom-dropdown-trigger modal-input" data-options='${JSON.stringify( optionsArray )}'>Select option</div> </div> `, footer: ` <button onclick="closeModal()">Cancel</button> <button onclick="handleFormatSubmit('${t}')" class="modal-btn">OK</button> ` }); if (!result || result.action !== "OK") return; const formatValue = result.format; if (!formatValue) return; const sel = v.slice(s, e); let formatted = ""; if (t === "italic") formatted = formatValue === "2" ? `<i>${sel}</i>` : `*${sel}*`; else if (t === "underline") formatted = formatValue === "2" ? `<u>${sel}</u>` : `__${sel}__`; else if (t === "bold") formatted = formatValue === "2" ? `<b>${sel}</b>` : `**${sel}**`; else if (t === "code") formatted = formatValue === "2" ? `<code>${sel}</code>` : `\`\`\`\n${sel}\n\`\`\``; noteTextarea.value = v.slice(0, s) + formatted + v.slice(e); updateNoteMetadata(); showNotification(`Text ${t} applied!`); })(); }; window.handleFormatSubmit = function (type) { const formatValue = modalScope.formatType ? modalScope.formatType.dataset.value : null; if (!formatValue) { showNotification("Please select a format!"); return; } closeModal({ action: "OK", format: formatValue, type: type }); };window.handleBulletList = function () { return preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; if (s === e) { showNotification("Please select text for bullet list!"); return; } const optionsArray = [ { label: "Select option", value: "" }, { label: "MarkDown (- item)", value: "1" }, { label: "MarkUp (&lt;ul&gt;&lt;li&gt;)", value: "2" } ]; const result = await showModal({ header: `<div class="modal-title">Bullet List</div>`, body: ` <label class="modal-label">Choose Format</label> <div class="custom-dropdown"> <div id="listFormat" class="custom-dropdown-trigger modal-input" data-options='${JSON.stringify( optionsArray )}'>Select option</div> </div> `, footer: ` <button onclick="closeModal()">Cancel</button> <button onclick="handleListSubmit('bullet')" class="modal-btn">OK</button> ` }); if (!result || result.action !== "OK") return; const formatValue = result.format; if (!formatValue) return; const sel = v.slice(s, e), lines = sel.split(/\r?\n/); let formatted; if (formatValue === "2") { formatted = "<ul>\n" + lines.map((t) => "<li>" + t + "</li>").join("\n") + "\n</ul>"; } else { formatted = lines.map((t) => "- " + t).join("\n"); } noteTextarea.value = v.slice(0, s) + formatted + v.slice(e); updateNoteMetadata(); showNotification("Bullet list applied!"); })(); };window.handleNumberedList = function () { return preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; if (s === e) { showNotification("Please select text for numbered list!"); return; } const optionsArray = [ { label: "Select option", value: "" }, { label: "MarkDown (1. item)", value: "1" }, { label: "MarkUp (&lt;ol&gt;&lt;li&gt;)", value: "2" } ]; const result = await showModal({ header: `<div class="modal-title">Numbered List</div>`, body: ` <label class="modal-label">Choose Format</label> <div class="custom-dropdown"> <div id="listFormat" class="custom-dropdown-trigger modal-input" data-options='${JSON.stringify( optionsArray )}'>Select option</div> </div> `, footer: ` <button onclick="closeModal()">Cancel</button> <button onclick="handleListSubmit('numbered')" class="modal-btn">OK</button> ` }); if (!result || result.action !== "OK") return; const formatValue = result.format; if (!formatValue) return; const sel = v.slice(s, e), lines = sel.split(/\r?\n/); let formatted; if (formatValue === "2") { formatted = "<ol>\n" + lines.map((t) => "<li>" + t + "</li>").join("\n") + "\n</ol>"; } else { formatted = lines.map((t, i) => i + 1 + ". " + t).join("\n"); } noteTextarea.value = v.slice(0, s) + formatted + v.slice(e); updateNoteMetadata(); showNotification("Numbered list applied!"); })(); };window.handleListSubmit = function (type) { const formatValue = modalScope.listFormat ? modalScope.listFormat.dataset.value : null; if (!formatValue) { showNotification("Please select a format!"); return; } closeModal({ action: "OK", format: formatValue, listType: type }); };window.handleInsertLink = function () { return preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; const formatOptionsArray = [ { label: "Select option", value: "" }, { label: "Markdown", value: "markdown" }, { label: "MarkUp", value: "markup" } ]; const result = await showModal({ header: `<div class="modal-title">Insert Link</div>`, body: ` <div style="display: flex; gap: 10px; align-items: center;"> <div style="flex: 1;"> <label class="modal-label">URL</label> <input type="url" id="linkUrl" placeholder="Enter URL"> </div> </div> <div style="display: flex; gap: 10px; align-items: center;"> <div style="flex: 1;"> <label class="modal-label">Link Text</label> <input type="text" id="linkText" placeholder="Enter link text"> </div> </div> <div style="display: flex; gap: 10px; align-items: center;"> <div style="flex: 1;"> <label class="modal-label">Format</label> <div class="custom-dropdown"> <div id="linkFormat" class="custom-dropdown-trigger modal-input" data-options='${JSON.stringify( formatOptionsArray )}'>Select option</div> </div> </div> </div> `, footer: ` <button onclick="closeModal()">Cancel</button> <button onclick="handleLinkSubmit()" class="modal-btn">Submit</button> ` }); if (!result || result.action !== "submit") return; const url = result.url; const text = result.text; const format = result.format; if (!url || !text || !format) return; const link = format === "markup" ? `<a href="${url}">${text}</a>` : `[${text}](${url})`; noteTextarea.value = v.slice(0, s) + link + v.slice(e); updateNoteMetadata(); showNotification("Link inserted!"); })(); }; window.handleLinkSubmit = function () { const url = modalScope.linkUrl ? modalScope.linkUrl.value.trim() : ""; const text = modalScope.linkText ? modalScope.linkText.value.trim() : ""; const format = modalScope.linkFormat ? modalScope.linkFormat.dataset.value : ""; if (!url || !text || !format) { showNotification("Please fill in all fields!"); return; } closeModal({ action: "submit", url: url, text: text, format: format }); };window.handleInsertImage = function () { return preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; const formatOptionsArray = [ { label: "Select option", value: "" }, { label: "Markdown", value: "markdown" }, { label: "MarkUp", value: "markup" } ]; const result = await showModal({ header: `<div class="modal-title">Insert Image</div>`, body: ` <div style="display: flex; gap: 10px; align-items: center;"> <div style="flex: 1;"> <label class="modal-label">Image URL</label> <input type="url" id="imageUrl" placeholder="Enter image URL"> </div> </div> <div style="display: flex; gap: 10px; align-items: center;"> <div style="flex: 1;"> <label class="modal-label">Format</label> <div class="custom-dropdown"> <div id="imageFormat" class="custom-dropdown-trigger modal-input" data-options='${JSON.stringify( formatOptionsArray )}'>Select option</div> </div> </div> </div> `, footer: ` <button onclick="closeModal()">Cancel</button> <button onclick="handleImageSubmit()" class="modal-btn">Insert</button> ` }); if (!result || result.action !== "submit") return; const url = result.url; const format = result.format; if (!url || !format) return; const image = format === "markup" ? `<img src="${url}" alt="Image" />` : `![Image](${url})`; noteTextarea.value = s === e ? v + image : v.slice(0, s) + image + v.slice(e); updateNoteMetadata(); showNotification("Image inserted!"); })(); }; window.handleImageSubmit = function () { const url = modalScope.imageUrl ? modalScope.imageUrl.value.trim() : ""; const format = modalScope.imageFormat ? modalScope.imageFormat.dataset.value : ""; if (!url || !format) { showNotification("Please fill in all fields!"); return; } closeModal({ action: "submit", url: url, format: format }); };window.handleUppercase = function () { const r = preserveSelection(function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; if (!v) return; const f = s === e ? v.toUpperCase() : v.slice(0, s) + v.slice(s, e).toUpperCase() + v.slice(e); noteTextarea.value = f; updateNoteMetadata(); showNotification("Converted to uppercase!"); }); return typeof r === "function" ? r() : r; }; window.handleLowercase = function () { const r = preserveSelection(function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; if (!v) return; const f = s === e ? v.toLowerCase() : v.slice(0, s) + v.slice(s, e).toLowerCase() + v.slice(e); noteTextarea.value = f; updateNoteMetadata(); showNotification("Converted to lowercase!"); }); return typeof r === "function" ? r() : r; }; window.handleAlignLeft = function () { if (!noteTextarea) return; noteTextarea.style.textAlign = "left"; showNotification("Text aligned left!"); }; window.handleAlignCenter = function () { if (!noteTextarea) return; noteTextarea.style.textAlign = "center"; showNotification("Text aligned center!"); }; window.handleAlignRight = function () { if (!noteTextarea) return; noteTextarea.style.textAlign = "right"; showNotification("Text aligned right!"); }; window.increaseIndentation = function () { const r = preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd; if (s === e) { showNotification("Please select text to indent!"); return; } const t = noteTextarea.value.slice(s, e), i = "\t" + t.replace(/\n/g, "\n\t"); noteTextarea.value = noteTextarea.value.slice(0, s) + i + noteTextarea.value.slice(e); updateNoteMetadata(); showNotification("Text indented!"); }); return "function" == typeof r ? r() : r; }; window.decreaseIndentation = function () { const r = preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd; if (s === e) { showNotification("Please select text to un-indent!"); return; } const t = noteTextarea.value.slice(s, e).split("\n"), i = t .map((e) => e.startsWith("\t") ? e.slice(1) : e.startsWith(" ") ? e.slice(4) : e ) .join("\n"); noteTextarea.value = noteTextarea.value.slice(0, s) + i + noteTextarea.value.slice(e); updateNoteMetadata(); showNotification("Indentation removed!"); }); return "function" == typeof r ? r() : r; }; window.handleSelectAll = function () { if (!currentNote || !noteTextarea) return; noteTextarea.setSelectionRange(0, noteTextarea.value.length); noteTextarea.blur(); showNotification("All text selected!"); }; window.handleCopyNote = function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, t = s === e ? noteTextarea.value : noteTextarea.value.slice(s, e); navigator.clipboard .writeText(t) .then(() => showNotification("Copied to clipboard!")) .catch(() => showNotification("Copy failed (clipboard not available).") ); }; window.handleCutNote = function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, t = s === e ? noteTextarea.value : noteTextarea.value.slice(s, e); navigator.clipboard .writeText(t) .then(() => { noteTextarea.value = s === e ? "" : noteTextarea.value.slice(0, s) + noteTextarea.value.slice(e); noteTextarea.selectionStart = noteTextarea.selectionEnd = s; updateNoteMetadata(); showNotification("Cut to clipboard!"); }) .catch(() => showNotification("Cut failed (clipboard not available).")); }; window.handleClearNote = function () { const r = preserveSelection(async function () { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd, v = noteTextarea.value; if (s === e) { noteTextarea.value = ""; } else { noteTextarea.value = v.slice(0, s) + v.slice(e); } updateNoteMetadata(); showNotification("Note cleared!"); }); return "function" == typeof r ? r() : r; };window.handlePasteNote = function () { const r = async function () { if (!currentNote || !noteTextarea) return; if (!navigator.clipboard || !navigator.permissions) { showNotification("Paste not supported in this browser."); return; } try { const perm = await navigator.permissions.query({ name: "clipboard-read" }); if (perm.state === "denied") { showNotification( "Clipboard access denied. Please allow it in your browser settings." ); return; } const clip = await navigator.clipboard.readText(); const s = noteTextarea.selectionStart, e = noteTextarea.selectionEnd; noteTextarea.value = noteTextarea.value.slice(0, s) + clip + noteTextarea.value.slice(e); const n = s + clip.length; noteTextarea.selectionStart = noteTextarea.selectionEnd = n; updateNoteMetadata(); showNotification("Pasted from clipboard!"); } catch { showNotification( "Paste failed (permission denied or empty clipboard)." ); } }; r(); };
window.handlePattern = async function () { if (!currentNote || !noteTextarea) return; const r = await showModal({ header: `<div class="modal-title">Replace Between Delimiters</div>`, body: `<div><label class="modal-label">Start delimiter</label><input type="text" id="startDelim" placeholder="Start delimiter (required)"></div><div><label class="modal-label">End delimiter</label><input type="text" id="endDelim" placeholder="End delimiter (required)"></div><div style="display:flex;align-items:center;gap:8px;margin-top:6px;"><input type="checkbox" id="includeDelims"><label for="includeDelims" class="modal-label">Include delimiters in replacement</label></div><div><label class="modal-label">Replacement text</label><input type="text" id="replaceText" placeholder="Replacement text" data-skip-validation></div><div style="margin-top:8px;font-weight:600;">Which instances to replace?</div><div style="display:flex;gap:8px;margin-top:4px;"><button type="button" id="allMode" class="modal-btn active" data-mode="all">All</button><button type="button" id="singleMode" class="modal-btn" data-mode="single">Single</button><button type="button" id="rangeMode" class="modal-btn" data-mode="range">Range</button></div><div id="singleContainer" style="display:none;margin-top:6px;"><label class="modal-label">Instance number (1-based)</label><input type="number" id="singleInstance" min="1" value="1"></div><div id="rangeContainer" style="display:none;margin-top:6px;display:flex;gap:8px;"><div><label class="modal-label">From (1-based)</label><input type="number" id="rangeFrom" min="1" value="1"></div><div><label class="modal-label">To (1-based)</label><input type="number" id="rangeTo" min="1" value="1"></div></div><div id="matchInfo" style="font-size:13px;color:var(--blueink);margin-top:6px;">Matches: 0</div>`, footer: `<button onclick="closeModal()">Cancel</button><button onclick="handlePatternSubmit()" class="modal-btn">Replace</button>` }); if (!r || r.action !== "submit") return; const { startDelim, endDelim, includeDelims, replaceText, mode, singleInstance, rangeFrom, rangeTo } = r; if (!startDelim) return showNotification("Start delimiter required"); if (!endDelim) return showNotification("End delimiter required"); const text = noteTextarea.value, pairs = findPairs(text, startDelim, endDelim); if (!pairs.length) return showNotification("No matches found"); let from = 1, to = pairs.length; if (mode === "single") { const n = parseInt(singleInstance, 10); if (isNaN(n) || n < 1) return showNotification("Invalid instance number"); from = to = Math.min(Math.max(n, 1), pairs.length); } else if (mode === "range") { const f = parseInt(rangeFrom, 10), t = parseInt(rangeTo, 10); if (isNaN(f) || isNaN(t)) return showNotification("Invalid range"); from = Math.min(Math.max(f, 1), pairs.length); to = Math.min(Math.max(t, from), pairs.length); } try { let out = text; for (let i = pairs.length - 1; i >= 0; i--) { const pair = pairs[i], idx1 = i + 1; if (idx1 < from || idx1 > to) continue; const before = out.slice(0, pair.startIndex), after = out.slice(pair.endIndex); let middle; if (includeDelims) { middle = replaceText; } else { middle = startDelim + replaceText + endDelim; } out = before + middle + after; } noteTextarea.value = out; typeof updateNoteMetadata === "function" && updateNoteMetadata(); const replacedCount = Math.max( 0, Math.min(to, pairs.length) - from + 1 ); showNotification( `Replacement done! (${replacedCount} instance(s) replaced)` ); } catch (err) { console.error("Replacement error", err); showNotification("Replacement failed — see console"); } }; window.handlePatternSubmit = function () { const s = modalScope.startDelim ? modalScope.startDelim.value.trim() : "", e = modalScope.endDelim ? modalScope.endDelim.value.trim() : "", inc = modalScope.includeDelims ? modalScope.includeDelims.checked : false, rep = modalScope.replaceText ? modalScope.replaceText.value : "", mode = modalScope.allMode && modalScope.allMode.classList.contains("active") ? "all" : modalScope.singleMode && modalScope.singleMode.classList.contains("active") ? "single" : "range", si = modalScope.singleInstance ? modalScope.singleInstance.value : "1", rf = modalScope.rangeFrom ? modalScope.rangeFrom.value : "1", rt = modalScope.rangeTo ? modalScope.rangeTo.value : "1"; closeModal({ action: "submit", startDelim: s, endDelim: e, includeDelims: inc, replaceText: rep, mode: mode, singleInstance: si, rangeFrom: rf, rangeTo: rt }); }; document.addEventListener("click", function (e) { if (!modalScope) return; const id = e.target && e.target.id; if (id === "allMode" || id === "singleMode" || id === "rangeMode") { ["allMode", "singleMode", "rangeMode"].forEach( (i) => modalScope[i] && modalScope[i].classList.remove("active") ); e.target.classList.add("active"); modalScope.singleContainer && (modalScope.singleContainer.style.display = id === "singleMode" ? "block" : "none"); modalScope.rangeContainer && (modalScope.rangeContainer.style.display = id === "rangeMode" ? "flex" : "none"); } }); document.addEventListener("input", function (e) { if (!modalScope) return; const tid = e.target && e.target.id; if (tid === "startDelim" || tid === "endDelim") { const s = modalScope.startDelim ? modalScope.startDelim.value : "", f = modalScope.endDelim ? modalScope.endDelim.value : ""; if (!s || !f) { modalScope.matchInfo && (modalScope.matchInfo.textContent = "Matches: 0"); return; } const pairs = findPairs(noteTextarea.value, s, f); modalScope.matchInfo && (modalScope.matchInfo.textContent = `Matches: ${pairs.length}`); if (pairs.length) { modalScope.rangeFrom && (modalScope.rangeFrom.value = "1"); modalScope.rangeTo && (modalScope.rangeTo.value = String(pairs.length)); modalScope.singleInstance && (modalScope.singleInstance.value = "1"); } } }); function findPairs(text, startDelim, endDelim) { const pairs = []; if (!startDelim || !endDelim) return pairs; const sLen = startDelim.length, eLen = endDelim.length, stack = []; let i = 0; while (i < text.length) { if (text.substr(i, sLen) === startDelim) { stack.push(i); i += sLen; continue; } if (text.substr(i, eLen) === endDelim) { if (stack.length > 0) { const startIdx = stack.pop(), endIdx = i + eLen; pairs.push({ startIndex: startIdx, endIndex: endIdx }); } i += eLen; continue; } i++; } return pairs.sort((a, b) => a.startIndex - b.startIndex); }
window.handleDownload = async function () { if (!currentNote || !noteTextarea) return; const dfn = `${currentNote.title || "note"}.${ currentNote.extension || "txt" }`.replace(/"/g, "&quot;"); const res = await showModal({ header: `<div class="modal-title">Download Note</div>`, body: `<div style="display: flex; gap: 10px; align-items: center;"><div style="flex: 1;"><label class="modal-label">Filename</label><input type="text" id="fileName" placeholder="Enter filename including extension" value="${dfn}"></div></div>`, footer: `<button onclick="closeModal()">Cancel</button><button onclick="handleDownloadSubmit()" data-skip-validation class="modal-btn">Download</button>` }); if (!res || res.action !== "Download") return; let f = String(res.fileName || "").trim(); if (!f) return; f = f .replace(/\0/g, "") .replace(/[/\\]+/g, "") .replace(/["'<>:|?*]+/g, ""); const p = f.split("."), ext = p.length > 1 ? (p.pop() || "txt").toLowerCase() : "txt", name = p.join(".") || "note", mimeMap = { txt: "text/plain; charset=utf-8", text: "text/plain; charset=utf-8", md: "text/markdown; charset=utf-8", markdown: "text/markdown; charset=utf-8", csv: "text/csv; charset=utf-8", log: "text/plain; charset=utf-8", ini: "text/plain; charset=utf-8", conf: "text/plain; charset=utf-8", env: "text/plain; charset=utf-8", html: "text/html; charset=utf-8", htm: "text/html; charset=utf-8", css: "text/css; charset=utf-8", js: "application/javascript; charset=utf-8", mjs: "text/javascript; charset=utf-8", ts: "application/typescript; charset=utf-8", jsx: "text/jsx; charset=utf-8", tsx: "text/tsx; charset=utf-8", json: "application/json; charset=utf-8", xml: "application/xml; charset=utf-8", yaml: "text/yaml; charset=utf-8", yml: "text/yaml; charset=utf-8", png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg", webp: "image/webp", gif: "image/gif", svg: "image/svg+xml; charset=utf-8", ico: "image/vnd.microsoft.icon", woff: "font/woff", woff2: "font/woff2", ttf: "font/ttf", otf: "font/otf", mp3: "audio/mpeg", m4a: "audio/mp4", wav: "audio/wav", ogg: "audio/ogg", flac: "audio/flac", mp4: "video/mp4", m4v: "video/x-m4v", mov: "video/quicktime", webm: "video/webm", mkv: "video/x-matroska", avi: "video/x-msvideo", zip: "application/zip", tar: "application/x-tar", gz: "application/gzip", tgz: "application/gzip", bz2: "application/x-bzip2", xz: "application/x-xz", rar: "application/vnd.rar", "7z": "application/x-7z-compressed", pdf: "application/pdf", doc: "application/msword", docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document", xls: "application/vnd.ms-excel", xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", ppt: "application/vnd.ms-powerpoint", pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation", odt: "application/vnd.oasis.opendocument.text", ods: "application/vnd.oasis.opendocument.spreadsheet", odp: "application/vnd.oasis.opendocument.presentation", epub: "application/epub+zip", exe: "application/vnd.microsoft.portable-executable", dll: "application/octet-stream", bin: "application/octet-stream", wasm: "application/wasm", sh: "application/x-sh", bash: "application/x-sh", ps1: "text/plain; charset=utf-8", bat: "application/x-msdownload", sql: "text/x-sql; charset=utf-8", rtf: "application/rtf", svgz: "image/svg+xml; charset=utf-8", heic: "image/heic", heif: "image/heif" }, textLike = [ "text/plain", "text/markdown", "text/csv", "text/html", "application/json", "application/javascript", "application/xml", "text/yaml", "text/jsx", "text/tsx" ], mime = mimeMap[ext] || (/\.(jpg|jpeg|png|gif|webp|svg|ico)$/i.test(ext) ? `image/${ext}` : "application/octet-stream"); if (textLike.some((t) => mime.indexOf(t) === 0) && !/charset=/.test(mime)) mime += "; charset=utf-8"; const fileName = `${name}.${ext}`, blob = new Blob([noteTextarea.value], { type: mime }), url = URL.createObjectURL(blob), a = document.createElement("a"); a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(url), 1500); showNotification(`Note downloaded as ${fileName}!`); }; window.handleDownloadSubmit = function () { const fileName = modalScope.fileName ? modalScope.fileName.value : ""; closeModal({ action: "Download", fileName }); };
window.handleAdd = async () => { if (!currentNote || !noteTextarea) return; const r = await showModal({ header: `<div class="modal-title">Add Text to Lines</div>`, body: `<div style="display:flex;flex-direction:column;gap:10px;"><div><label class="modal-label">Insert text</label><input type="text" id="insertText" class="modal-input" placeholder="Text to insert (use %L for line number, %N for new line)" data-skip-validation></div><div><label class="modal-label">Insert position</label><div class="custom-dropdown"><div id="insertPosition" class="custom-dropdown-trigger modal-input" data-options='[{"label":"Insert at start of line","value":"start"},{"label":"Insert at end of line","value":"end"},{"label":"Insert at specific column","value":"column"}]' data-value="start">Insert at start of line</div></div></div><div id="colContainer" style="display:none"><label class="modal-label">Column number</label><input type="number" id="columnNumber" class="modal-input" placeholder="Column number (1-based)" min="1"></div></div>`, footer: `<button onclick="closeModal()">Cancel</button><button onclick="handleAddSubmit()" style="background: var(--accent2); color: #cacaca;">Add</button>`, html: true }); if (!r || r.action !== "submit") return; const { insertText, insertPosition, columnNumber } = r; const col = parseInt(columnNumber, 10) || 1; const lines = noteTextarea.value.split("\n"); let result = ""; for (let i = 0; i < lines.length; i++) { let line = lines[i]; const replacement = insertText .replace(/%L/g, String(i + 1)) .replace(/%N/g, "\n"); if (insertPosition === "start") { line = replacement + line; } else if (insertPosition === "end") { line = line + replacement; } else if (insertPosition === "column") { const idx = Math.max(0, col - 1); if (line.length < idx) { line = line.padEnd(idx, " "); } line = line.slice(0, idx) + replacement + line.slice(idx); } result += line + (i < lines.length - 1 ? "\n" : ""); } noteTextarea.value = result; if (typeof updateNoteMetadata === "function") updateNoteMetadata(); if (typeof updatecounts === "function") updatecounts(); showNotification("Text added successfully!"); }; window.handleAddSubmit = function () { const insertText = modalScope.insertText ? modalScope.insertText.value : ""; const insertPosition = modalScope.insertPosition ? modalScope.insertPosition.dataset.value : "start"; const columnNumber = modalScope.columnNumber ? modalScope.columnNumber.value : ""; closeModal({ action: "submit", insertText, insertPosition, columnNumber }); }; document.addEventListener("click", (e) => { if (!modalScope) return; const positionElem = modalScope.insertPosition; if (!positionElem) return; const value = positionElem.dataset.value || "start"; const colContainer = modalScope.colContainer; if (colContainer) { colContainer.style.display = value === "column" ? "block" : "none"; } });
window.handleCleanupText = async () => { if (!currentNote || !noteTextarea) return; const r = await showModal({ header: `<div class="modal-title">Cleanup Text</div>`, body: `<div style="display:flex;flex-direction:column;gap:10px;"><div><label class="modal-label">Choose Cleanup Style</label><div class="custom-dropdown"><div id="cleanupStyle" class="custom-dropdown-trigger modal-input" data-options='[{"label":"Select CleanUp Style","value":""},{"label":"Remove Linebreaks","value":"remove_linebreaks"},{"label":"Remove Parabreaks","value":"remove_parabreaks"},{"label":"Remove Both Line & Para Breaks","value":"remove_both"},{"label":"Whitespace Cleanup","value":"whitespace_cleanup"},{"label":"Trim Columns","value":"trim_columns"},{"label":"Tidy Lines","value":"tidy_lines"}]' data-value="">Select CleanUp Style</div></div></div><div id="trimContainer" style="display:none;flex-direction:column;gap:10px;"><div><label class="modal-label">Number of Columns</label><input type="number" id="trimNumber" class="modal-input" value="1" min="1"></div><div><label class="modal-label">Trim Side</label><div class="custom-dropdown"><div id="trimSide" class="custom-dropdown-trigger modal-input" data-options='[{"label":"Left","value":"left"},{"label":"Right","value":"right"}]' data-value="left">Left</div></div></div></div></div>`, footer: `<button onclick="closeModal()">Cancel</button><button onclick="handleCleanupSubmit()" style="background: var(--accent2); color: #cacaca;">Cleanup</button>`, html: true }); if (!r || r.action !== "submit") return; const { cleanupStyle, trimNumber, trimSide } = r; let text = noteTextarea.value; if (cleanupStyle === "remove_linebreaks") { text = text.replace(/\r\n|\r|\n/g, " "); } else if (cleanupStyle === "remove_parabreaks") { text = text.replace(/\n{3,}/g, "\n\n"); } else if (cleanupStyle === "remove_both") { text = text .replace(/\r\n|\r|\n/g, " ") .replace(/\s+/g, " ") .trim(); } else if (cleanupStyle === "whitespace_cleanup") { text = text .replace(/\t+/g, " ") .replace(/ {2,}/g, " ") .replace(/\n{3,}/g, "\n\n") .replace(/^\n+|\n+$/g, ""); } else if (cleanupStyle === "trim_columns") { const n = parseInt(trimNumber, 10) || 0; text = text .split("\n") .map((line) => { if (trimSide === "left") return line.slice(n); if (trimSide === "right") return line.slice(0, -n); return line; }) .join("\n"); } else if (cleanupStyle === "tidy_lines") { text = text .split("\n") .map((line) => line.trim()) .join("\n"); } noteTextarea.value = text; if (typeof updateNoteMetadata === "function") updateNoteMetadata(); showNotification("Text cleaned successfully!"); }; window.handleCleanupSubmit = function () { const cleanupStyle = modalScope.cleanupStyle ? modalScope.cleanupStyle.dataset.value : ""; const trimNumber = modalScope.trimNumber ? modalScope.trimNumber.value : "1"; const trimSide = modalScope.trimSide ? modalScope.trimSide.dataset.value : "left"; if (!cleanupStyle) return showNotification("Please select a cleanup style!"); closeModal({ action: "submit", cleanupStyle, trimNumber, trimSide }); }; document.addEventListener("click", (e) => { if (!modalScope) return; const styleElem = modalScope.cleanupStyle; if (!styleElem) return; const value = styleElem.dataset.value || ""; const trimContainer = modalScope.trimContainer; if (trimContainer) { trimContainer.style.display = value === "trim_columns" ? "flex" : "none"; } });
window.reverseText=preserveSelection(async()=>{if(!currentNote||!noteTextarea)return;let s=noteTextarea.selectionStart,e=noteTextarea.selectionEnd;if(s===e)noteTextarea.value=noteTextarea.value.split("").reverse().join("");else{let t=noteTextarea.value,n=t.substring(s,e),r=n.split("").reverse().join("");noteTextarea.value=t.substring(0,s)+r+t.substring(e)}try{updateNoteMetadata();showNotification("Text reversed!")}catch(err){console.error("Error updating note metadata:",err);showNotification("Failed to update note metadata")}});window.reverseWords = preserveSelection(async () => { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart; const e = noteTextarea.selectionEnd; if (s === e) { noteTextarea.value = noteTextarea.value .split(/\s+/) .reverse() .join(" "); } else { const t = noteTextarea.value; const n = t.substring(s, e); const r = n.split(/\s+/).reverse().join(" "); noteTextarea.value = t.substring(0, s) + r + t.substring(e); } updateNoteMetadata(); showNotification("Words reversed!"); });window.capitalizeWords = preserveSelection(async () => { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart; const e = noteTextarea.selectionEnd; if (s === e) { noteTextarea.value = noteTextarea.value.replace( /\b\w+/g, (t) => t.charAt(0).toUpperCase() + t.slice(1).toLowerCase() ); } else { const t = noteTextarea.value; const n = t.substring(s, e); const r = n.replace( /\b\w+/g, (t) => t.charAt(0).toUpperCase() + t.slice(1).toLowerCase() ); noteTextarea.value = t.substring(0, s) + r + t.substring(e); } updateNoteMetadata(); showNotification("Words capitalized!"); });window.capitalizeSentences = preserveSelection(async () => { if (!currentNote || !noteTextarea) return; const s = noteTextarea.selectionStart; const e = noteTextarea.selectionEnd; if (s === e) { noteTextarea.value = noteTextarea.value .toLowerCase() .replace(/(^\s*[a-z])|([.!?]\s*[a-z])/g, (t) => t.toUpperCase()); } else { const t = noteTextarea.value; const n = t.substring(s, e).toLowerCase(); const r = n.replace(/(^\s*[a-z])|([.!?]\s*[a-z])/g, (t) => t.toUpperCase() ); noteTextarea.value = t.substring(0, s) + r + t.substring(e); } updateNoteMetadata(); showNotification("Sentences capitalized!"); });    window.handleOpenFile = function () { const e = getNextEmptyNote(); if (!e) { showNotification("No empty notes available! Clear a note to continue."); return; } const t = document.createElement("input"); t.type = "file"; t.accept = ".txt,.md,.csv,.json,.xml,.yml,.yaml,.js,.ts,.jsx,.tsx,.html,.css,.py,.java,.c,.cpp,.h,.go,.rb,.php,.rs,.swift,.sh,.bat,Dockerfile,Makefile,.env,.ini,.toml,.conf,.log,.dockerignore"; t.onchange = function (o) { const n = o.target.files[0]; if (n) { const r = new FileReader(); (r.onload = function (o) { let x = n.name.split("."), a = x.pop().toLowerCase(), base = x.join("."); e.title = base; e.content = o.target.result; e.extension = a; e.lastEdited = new Date().toISOString(); visibleNotes = 1; updateNoteVisibility(); openNote(e.id); showNotification("File opened!"); }), r.readAsText(n); } }; t.click(); };
window.handleFindReplace = async function () { if (!currentNote || !noteTextarea) return; const r = await showModal({ header: `<div class="modal-title">Find and Replace</div>`, body: `<div style="display: flex; gap: 10px; align-items: center;"><div style="flex: 1;"><label class="modal-label">Find</label><input type="text" id="findText" placeholder="Enter text to find"></div></div><div style="display: flex; gap: 10px; align-items: center;"><div style="flex: 1;"><label class="modal-label">Replace</label><input type="text" id="replaceText" placeholder="Enter replacement text" data-skip-validation></div></div><div style="display: flex; align-items: center; margin-top: 8px;"><input type="checkbox" id="caseSensitive" style="color: var(--accent2);margin-right: 6px"><label for="caseSensitive" class="modal-label">Case sensitive</label></div>`, footer: `<button onclick="closeModal()">Cancel</button><button onclick="handleFindReplaceSubmit()" class="modal-btn">Replace</button>` }); if (!r || r.action !== "Replace") return; const f = r.findText.trim(), p = r.replaceText, c = r.caseSensitive === true; if (!f) { showNotification("Please enter text to find!"); return; } try { const e = f.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), t = new RegExp(e, c ? "g" : "gi"); (noteTextarea.value = noteTextarea.value.replace(t, p)), updateNoteMetadata(), showNotification("Text replaced!"); } catch (e) { showNotification("Error in find and replace!"); } }; window.handleFindReplaceSubmit = function () { const e = modalScope.findText ? modalScope.findText.value : "", t = modalScope.replaceText ? modalScope.replaceText.value : "", c = modalScope.caseSensitive ? modalScope.caseSensitive.checked : false; closeModal({ action: "Replace", findText: e, replaceText: t, caseSensitive: c }); };

